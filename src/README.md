## RED-BLACK TREE :red_circle: :black_circle:

- 자가 균형 이진 탐색 트리로서 연관 배열 등을 구현하는데 쓰이는 자료 구조이다.
- 높이가 $h$ 인 이진 탐색 트리에서 _삽입_, _검색_, _삭제_등과 같은 동작이 $O(h)$ 의 시간에 수행될 수 있는데, 최악의 경우 (이진 탐색 트리의 높이가 클 경우) 실행 속도가 일반적인 연결 리스트와 비슷한 정도에 블가하다.
- 레드 블랙 트리는 트리가 균형을 이루도록 설계된 검색 트리 구조 중 하나이다. 자료의 _삽입_과 _삭제_, _검색_의 동작이 최악의 경우에도 레드 블랙 트리의 높이인 $O(logn)$ 시간에 수행되도록 보장한다.

![Red-Black TREE](https://user-images.githubusercontent.com/72483138/144753423-b57c8286-3d7d-417d-8c8f-7f9990db21a5.png)

### 특징
- 각각의 노드가 _레드_ 나 _블랙_ 인 색상 속성을 가지고 있는 이진 탐색 트리이다. 따라서 이진 탐색 트리의 일반적인 조건을 만족한다.

<br>

- 아래 **조건**을 만족해야 유효한 **레드-블랙 트리**가 된다.
  1. 노드의 색은 _레드_ 혹은 _블랙_ 중의 하나이다.
  2. 루트 노드 색은 _블랙_ 이다
  3. 모든 리프 노드들(NIL) 은 _블랙_ 이다.
  4. 레드 노드의 자식노드 양쪽은 언제나 모두 _블랙_ 이다. (_레드_ 노드는 연달아 나타날 수 없으며, _블랙_ 노드만이 _레드_ 노드의 부모 노드가 될 수 있다)
  5. 어떤 노드로부터 시작되어 그에 속한 하위 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.

---
## 구현 범위
다음 기능들을 수행할 수 있도록 RB tree를 구현합니다.

- [x] tree = `new_tree()`: RB tree 구조체 생성

#### 회전
- [x] `left_rotation(tree, node)`: 해당 node를 기준으로 RB Tree 왼쪽 회전
  - 기준 node가 없다면 return 
- [x] `right_rotation(tree, node)`: 해당 node를 기준으로 RB Tree 오른쪽 회전 
  - - 기준 node가 없다면 return
- [x] `find_rotation_target(tree, node)`: rotation() 실행 전 회전하려는 노드 탐색 
  - 기준 노드가 있으면 1, 없다면 0 반환

- [ ] ptr = `tree_find(tree, key)`
    - RB tree내에 해당 key가 있는지 탐색하여 있으면 해당 node pointer 반환
    - 없으면 NIL 반환

#### 삽입
- [x] `tree_insert(tree, key)`: key 추가
- [x] `tree_insert_fixup(tree, node)` : 노드 삽입 후 RB Tree 특성 만족시키기 위해 노드의 색 변경 및 회전 수행


---

#### 회전 개요
- 중복된 키를 가진 노드를 기준으로 회전하
#### 삽입 개요
- `RB-INSERT(T, z)` 를 호출하면 `노드 z`가 `RB트리 T` 에 삽입된다.
- `이진 탐색 트리`의 삽입처럼 `노드 z`를 `트리 T`에 삽입한 뒤 `Z`를 빨간 노드로 칠한다.
- 삽입 후 `RB트리` 특성을 만족시키기 위해 `RB-INSERT-FIXUP` 을 통해 노드의 색깔을 바꾸고 회전을 수행한다.

##### `TREE-INSERT`와 `RB-INSERT` 의 차이
- `TREE-INSERT`에 나타나는 모든 `NIL`은 `T.nil`로 교체된다.
- 새로 삽입되는 `노드 z`의 `left`와 `right`는 `T.nil`로 지정된다.
- 새로 삽입되는 `노드 z`의 색깔을 빨간색으로 칠한다.
- 새로 삽입되는 `노드 z`의 색이 `빨간색`으로 되면서 레드블랙트리의 특성을 위반할 수 있으므로 `RB-INSERT-FIXUP(tree, node)`를 호출하여 특성을 만족할 수 있도록 한다.

##### `RB-INSERT-FIXUP(tree, node)` 의 동작
- 새로운 `노드 z`가 삽입되면서 발생 가능한 `레드블랙트리` 조건의 위반 사항
  - 루트 노드는 `검정색` 이어야한다.
    - `노드 z`가 루트일 때 위반
  - `빨간색` 노드는 `빨간색` 자식을 가질 수 없다.
    - `노드 z`의 부모가 `빨간색`일 때 위반 

- CASE 1
  - `노드 z`의 `삼촌 y`가 적색인 경우
    - `z.p.p`는 흑색이고, `z.p` 와 `y`는 적색이므로, 
    `z.p.p`를 적색으로 칠하고 `z.p` 와 `y`를 흑색하여 특성 5를 만족시킬 수 있다.
    - 그 다음 `z.p.p`를 `z`로 설정하여 위의 색 변화로 `RBTree` 의 위반 사항이 생겼는지 while문을 통해 확인한다.
- CASE 2
  - `z의 삼촌 y`가 흑색이며의 `z`가 오른쪽 자식인 경우
- CASE 3
  - `z의 삼촌 y`가 흑색이며의 `z`가 왼쪽 자식인 경우

> CASE 1 ~ 3 은 z의 부모가 조부모의 왼쪽 서브 트리일 경우와, 오른쪽 서브 트리일 경우로 나뉠 수 있기 때문에 총 6가지의 case가 생긴다.

---
### 그 외

#### `malloc`
- 인자로 전달된 크기 만큼 메모리를 할당한 후에, 그 메모리의 시작 주소값을 반환한다.
- 할당된 메모리는 초기화 되지 않았을 수도 있다. (기존의 있었단 내용이 남아 있을 수도 있다)
- 만일 `size`가 0 이라면, `malloc` 이 무엇을 리턴할지는 구현한 라이브러리 마다 다르다. 어떤 경우 널 포인터를 리턴할 수도 있고, 어떤 경우, 널이 아닌 포인터를 리턴하지만, 사용 불가능한 부분을 가리키고 있을 수도 있다. 어떤 경우든, 해당 주소값을 사용하면 안된다.
- 할당된 메모리는 반드시 `free` 로 해제해줘야 한다.
- **인자**
  - `size` : 메모리 블록의 크기(바이트 단위)
- **반환 값**
  - 메모리 할당에 성공하였을 경우, 할당한 메모리 블록을 가리키는 포인터를 리턴한다. 해당 포인터의 타입은 언제나 `void*` 이므로 사용자가 원하는 타입으로 캐스팅 해줘야 한다.
  - `malloc` 함수가 메모리 할당에 실패하였을 경우, `NULL` 포인터를 리턴한다.

#### `calloc`과 `malloc`의 차이
- `calloc`은 동적으로 메모리를 할당하고 할당된 메모리 블록을 `0`으로 초기화한다. 
- `malloc`은 동적으로 메모리를 할당하지만 할당된 메모리를 `0`으로 초기화하지않는다.
